'use strict'; // var BuildTarget = require('../../rollup/BuildTarget');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var LOG_PREFIX = '[UMENG] -- ';

var ulog = function () {
  var _instance = null;
  var _debug = false;

  function ULog() {
    this.setDebug = function (debug) {
      _debug = debug;
    };

    this.d = function () {
      if (_debug) {
        try {
          if (typeof arguments[0] === 'string') {
            arguments[0] = LOG_PREFIX + arguments[0];
          }

          console.debug.apply(console, arguments);
        } catch (e) {// e
        }
      }
    };

    this.i = function () {
      try {
        if (_debug) {
          try {
            if (typeof arguments[0] === 'string') {
              arguments[0] = LOG_PREFIX + arguments[0];
            }

            console.info.apply(console, arguments);
          } catch (e) {// e
          }
        }
      } catch (e) {// empty
      }
    };

    this.e = function () {
      if (_debug) {
        try {
          if (typeof arguments[0] === 'string') {
            arguments[0] = LOG_PREFIX + arguments[0];
          }

          console.error.apply(console, arguments);
        } catch (e) {// e
        }
      }
    };

    this.w = function () {
      if (_debug) {
        try {
          if (typeof arguments[0] === 'string') {
            arguments[0] = LOG_PREFIX + arguments[0];
          }

          console.warn.apply(console, arguments);
        } catch (e) {// e
        }
      }
    };

    this.v = function () {
      if (_debug) {
        try {
          if (typeof arguments[0] === 'string') {
            arguments[0] = LOG_PREFIX + arguments[0];
          }

          console.log.apply(console, arguments);
        } catch (e) {// e
        }
      }
    };

    this.t = function () {
      if (_debug) {
        try {
          console.table.apply(console, arguments);
        } catch (e) {// e
        }
      }
    };

    this.tip = function () {
      try {
        if (typeof arguments[0] === 'string') {
          arguments[0] = LOG_PREFIX + arguments[0];
        }

        console.log.apply(console, arguments);
      } catch (e) {// e
      }
    };

    this.tip_w = function () {
      try {
        if (typeof arguments[0] === 'string') {
          arguments[0] = LOG_PREFIX + arguments[0];
        }

        console.warn.apply(console, arguments);
      } catch (e) {// e
      }
    };

    this.err = function () {
      try {
        if (typeof arguments[0] === 'string') {
          arguments[0] = LOG_PREFIX + arguments[0];
        }

        console.error.apply(console, arguments);
      } catch (e) {// e
      }
    };
  }

  return function () {
    if (_instance === null) {
      _instance = new ULog();
    }

    return _instance;
  };
}();

var ustorage = {
  /**
   * 存储数据
   * @param key
   * @param value
   */
  set: function set(key, value, callback) {
    var options = {
      key: key,
      success: function success(data) {
        typeof callback === 'function' && callback(data);
      },
      fail: function fail() {
        typeof callback === 'function' && callback();
      }
    };
    var setStorage;
    {
      options.data = value;
      setStorage = wx.setStorage;
    }

    try {
      setStorage && setStorage(options);
    } catch (e) {
      ulog.e('存储错误', e);
    }
  },

  /**
   * 根据key获取数据
   * @param key
   * @param callback
   */
  get: function get(key, callback) {
    var getStorage;
    {
      getStorage = wx.getStorage;
    }

    try {
      getStorage && getStorage({
        key: key,
        success: function success(res) {
          typeof callback === 'function' && callback(res.data);
        },
        fail: function fail(e) {
          ulog().w(key + ': ' + e.errMsg);
          typeof callback === 'function' && callback();
        } // complete: function(data) {
        //   typeof callback === 'function' && callback("wx" === BuildTarget.QUICKAPP ? data : data.data);
        // }

      });
    } catch (e) {
      ulog.e('获取storage错误', e);
    }
  },

  /**
   * 删除key对应的数据
   * @param key
   */
  remove: function remove(key, callback) {
    var removeStorage;
    {
      removeStorage = wx.removeStorage;
    }

    try {
      removeStorage && removeStorage({
        key: key,
        success: function success()
        /* data */
        {
          typeof callback === 'function' && callback(true);
        },
        fail: function fail()
        /* data, code */
        {
          typeof callback === 'function' && callback(false);
        }
      });
    } catch (e) {
      ulog.e('删除storage错误', e);
    }
  }
};
var jsonUtil = {
  /**
   * 将对像转为字符串
   * @param json
   * @returns {string}
   */
  stringify: function stringify(data) {
    if (data) {
      try {
        return JSON.stringify(data);
      } catch (e) {// empty
      }
    }

    return '';
  },

  /**
   * 字符串转为对象
   * @param str
   * @returns {*}
   */
  parse: function parse(json) {
    if (json) {
      try {
        return JSON.parse(json);
      } catch (e) {// empty
      }
    }

    return null;
  },
  parseToArray: function parseToArray(json) {
    if (json) {
      try {
        return JSON.parse(json);
      } catch (e) {// empty
      }
    }

    return [];
  }
};

var userConfig = function () {
  var _instance = null;

  function UserConfig() {
    var _config = {};
    {
      this.useOpenid = function () {
        return _config.useOpenid;
      };

      this.autoGetOpenid = function () {
        return _config.autoGetOpenid;
      };
    }

    this.appKey = function () {
      return _config.appKey;
    };

    this.set = function (config) {
      _config = config;
    };

    this.get = function () {
      return _config;
    };

    this.setItem = function (key, value) {
      _config[key] = value;
    };

    this.getItem = function (key) {
      return _config[key];
    };
  }

  return function () {
    if (!_instance) {
      _instance = new UserConfig();
    }

    return _instance;
  };
}(); // import ulog from '../utils/ulog.js';


var cache = function () {
  var _instance = null;
  var _name = '';
  var _data = null;
  var _loaded = false;

  function Cache() {
    this.load = function (cb) {
      if (!_data) {
        _name = 'um_cache_' + userConfig().appKey();
        ustorage.get(_name, function (data) {
          _data = jsonUtil.parse(data) || {};
          _loaded = true;
          ustorage.remove(_name);
          cb();
        });
      } else {
        ustorage.remove(_name);
        cb();
      }
    };

    this.save = function () {
      if (_data) {
        ustorage.set(_name, jsonUtil.stringify(_data));
      }
    };

    this.set = function (key, value) {
      if (_data) {
        _data[key] = value;
      }
    };

    this.get = function (key) {
      return (_data || {})[key];
    };

    this.remove = function (key) {
      if (_data && _data[key]) {
        delete _data[key];
      }
    };

    this.getAll = function () {
      return _data;
    };

    this.clear = function () {
      _data = null;
    };

    this.has = function (key) {
      return !!this.get(key);
    };

    this.isLoaded = function () {
      return _loaded;
    };
  }

  return function (appkey) {
    if (!_instance) {
      _instance = new Cache(appkey);
    }

    return _instance;
  };
}();

var WX_LOG_URL_PREV = 'https://preulogs.umeng.com/wxm_logs'; // 微信小程序发数测试服务器

var GET_OPENID_URL_PREV = 'http://pre-mpserv.umeng.com/uminiprogram_logs/wx/getuut'; // 获取openid预发地址
// var SDK_UPDATE_HOST_PRE = 'https://pre-w.cnzz.com'; // 热更新预发服务器
// var SDK_UPDATE_HOST_PRODUCT = 'https://s.cnzz.com'; // 热更新正式服务器

var logUrl = '';
{
  logUrl = WX_LOG_URL_PREV;
} // var sdkUpdateUrl = SDK_UPDATE_HOST_PRODUCT;

var IS_ALIYUN = false;
var constants = {
  SESSION_INTERVAL: 30000,
  // sessionId过期时间 30000
  LOG_URL: logUrl,
  GET_OPENID_URL: GET_OPENID_URL_PREV,
  DEVICE_INFO_KEY: 'device_info',
  ADVERTISING_ID: 'mobile_ad_id',
  ANDROID_ID: 'android_id',
  CURRENT_SESSION: 'current_session',
  // 本地存储的当前session对象
  SESSION_PAUSE_TIME: 'session_pause_time',
  EVENT_SEND_MIN_INTERVAL: 5,
  // ekv事件发送时间间隔-最小: 90
  EVENT_SEND_MAX_INTERVAL: 86400,
  // ekv事件发送时间间隔-最大
  EVENT_LAST_SEND_TIME: 'last_send_time',
  MAX_EVENTID_LENGTH: 128,
  MAX_PROPERTY_KEY_LENGTH: 256,
  MAX_PROPERTY_KEYS_COUNT: 100,
  REPORT_POLICY: 'report_policy',
  // 发送策略
  REPORT_INTERVAL_TIME: 'report_interval_time',
  // 间隔发送用户设置时间
  REPORT_POLICY_START_SEND: '1',
  // 启动发送
  REPORT_POLICY_INTERVAL: '6',
  // 间隔发送
  IMPRINT: 'imprint',
  // // 热更新相关
  // DOWNLOAD_FILE_FIRST_CACHE: 'hot_update_first',
  // DOWNLOAD_FILE_SECOND_CACHE: 'hot_update_second',
  // // 热更新地址
  // SDK_UPDATE_SERVER_ADDRESS: sdkUpdateUrl +
  //   ("wx" === BuildTarget.ALIPAY ? '/sdk/alipay' : '/sdk/quickapp'),
  // SDK_UPDATE_LOCAL_STORAGE_PATH: 'internal://files/umengsdk/',
  // SDK_CODE: 'umeng_sdk_cache',
  // SDK_INFO: 'umeng_sdk_info',
  // 种子代码版本
  SEED_VERSION: '1.0.0',
  // sdk代码版本，被热更新的代码的版本，每次发布时要增加版本号，同时保证和服务端配置一致
  IMPL_VERSION: '2.1.0',
  // 支付宝小程序版本，小于该版本将拿不到统计信息
  ALIPAY_AVAILABLE_VERSION: '10.1.52',
  SHARE_PATH: 'um_share_path',
  SHARES: 'shares',
  REQUESTS: 'requests',
  UUID: 'um_uuid',
  UUID_SUFFIX: 'ud',
  OPENID: 'um_od',
  UNIONID: 'um_unid',
  ALIPAYID: 'um_alipayid',
  USERID: 'um_userid',
  LAUNCH_OPTIONS: 'LAUNCH_OPTIONS',
  UM_SSRC: '_um_ssrc',
  IS_ALIYUN: IS_ALIYUN,
  ALIYUN_URL: 'serverless.huoban.youmeng.network.forward'
};
var udevice = {
  getUserInfo: function getUserInfo(callback) {
    {
      wx.getSetting({
        success: function success(res1) {
          if (res1.authSetting['scope.userInfo']) {
            wx.getUserInfo({
              success: function success(res2) {
                callback(res2 && res2.userInfo);
              },
              fail: function fail() {
                callback({});
              }
            });
          } else {
            callback({});
          }
        },
        fail: function fail() {
          callback({});
        }
      });
    }
  },
  // 获取设备不用授权的信息
  getSystemInfo: function getSystemInfo(callback, failCallback) {
    {
      wx.getSystemInfo({
        success: function success(info) {
          typeof callback === 'function' && callback(info);
        },
        fail: function fail()
        /* code */
        {
          typeof failCallback === 'function' && failCallback();
        }
      }); // ulog().e('unknown target: ' + TARGET + 'in getSystemInfo');
    }
  },
  getDeviceInfo: function getDeviceInfo(cb) {
    {
      typeof cb === 'function' && cb();
    }
  },
  checkNetworkAvailable: function checkNetworkAvailable(cb) {
    var options = {
      success: function success(res) {
        var available = false;
        {
          available = res.networkType !== 'none';
        }
        typeof cb === 'function' && cb(available);
      },
      fail: function fail()
      /* code */
      {
        typeof cb === 'function' && cb();
      }
    };
    {
      wx.getNetworkType(options);
    }
  },
  // 获取网络信息
  getNetworkInfo: function getNetworkInfo(callback, failCallback) {
    var options = {
      success: function success(info) {
        typeof callback === 'function' && callback(info);
      },
      fail: function fail()
      /* code */
      {
        typeof failCallback === 'function' && failCallback();
      }
    };
    {
      wx.getNetworkType(options);
    }
  },
  // 获取用户唯一标识 (androidid)
  getDeviceId: function getDeviceId(callback, failCallback) {
    try {
      {
        typeof callback === 'function' && callback('');
      }
    } catch (e) {
      ulog().e('getDeviceId error', e);
    }
  },
  // 获取广告唯一标识
  getAdvertisingId: function getAdvertisingId(callback, failCallback) {
    {
      typeof callback === 'function' && callback('');
    }
  },
  getPageName: function getPageName() {},
  onNetworkStatusChange: function onNetworkStatusChange(callback) {
    {
      wx.onNetworkStatusChange(function (result) {
        typeof callback === 'function' && callback(result.isConnected || true);
      });
    }
  }
};

var pageList = function () {
  var _instance = null;

  function PageList() {
    var hasTracked = false;
    var _currentPage = null;
    var _pages = [];

    this.addPageStart = function (page) {
      if (page && !hasTracked) {
        _currentPage = {
          ts: Date.now(),
          path: page
        };
        hasTracked = true;
      }
    };

    this.addPageEnd = function (page) {
      // 验证sessionId存在
      if (hasTracked && page && _currentPage && page === _currentPage.path) {
        var duration = Date.now() - _currentPage.ts;

        _currentPage.duration = Math.abs(duration);

        _pages.push(_currentPage);

        _currentPage = null;
        hasTracked = false;
      }
    };

    this.get = function () {
      return _pages;
    };

    this.clear = function () {
      _pages.length = 0;
    };
  }

  return function () {
    if (!_instance) {
      _instance = new PageList();
    }

    return _instance;
  };
}();

var MAX_REQUEST_TIMEOUT = 5000;

function send(options) {
  {
    requestWithTimeout(wx.request, options);
  }
}

function requestWithTimeout(request, options) {
  var srcSuccess = options.success;
  var srcFail = options.fail;
  var isTimeout = false;
  var st = null;

  options.success = function (resp) {
    if (!isTimeout) {
      st && clearTimeout(st);
      typeof srcSuccess === 'function' && srcSuccess(resp);
    }
  };

  options.fail = function () {
    if (!isTimeout) {
      st && clearTimeout(st);
      typeof srcFail === 'function' && srcFail();
    }
  };

  request(options);
  st = setTimeout(function () {
    st && clearTimeout(st);
    isTimeout = true;
    typeof srcFail === 'function' && srcFail(isTimeout);
  }, options.timeout || MAX_REQUEST_TIMEOUT);
}

function urequest(options) {
  try {
    udevice.getNetworkInfo(function (info) {
      if (info.networkType === 'NOTREACHABLE' || info.networkType === 'none' || info.networkAvailable === false) {
        ulog().e('请求失败:暂无网络 ');
        options.fail();
      } else {
        send(options);
      }
    }, options.fail);
  } catch (e) {
    ulog().e('请求失败: ' + e);
  }
}

var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var b64tab = function (bin) {
  var t = {};

  for (var i = 0, l = bin.length; i < l; i++) {
    t[bin.charAt(i)] = i;
  }

  return t;
}(b64chars);

var fromCharCode = String.fromCharCode;

var cb_utob = function cb_utob(c) {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
  }
};

var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;

var utob = function utob(u) {
  return u.replace(re_utob, cb_utob);
};

var cb_encode = function cb_encode(ccc) {
  var padlen = [0, 2, 1][ccc.length % 3],
      ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
      chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
  return chars.join('');
};

var btoa = function btoa(b) {
  return b.replace(/[\s\S]{1,3}/g, cb_encode);
};

var _encode = function _encode(u) {
  return btoa(utob(u));
};

var encode = function encode(u, urisafe) {
  return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function (m0) {
    return m0 == '+' ? '-' : '_';
  }).replace(/=/g, '');
};

var re_btou = new RegExp(['[À-ß][-¿]', '[à-ï][-¿]{2}', '[ð-÷][-¿]{3}'].join('|'), 'g');

var cb_btou = function cb_btou(cccc) {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3),
          offset = cp - 65536;
      return fromCharCode((offset >>> 10) + 55296) + fromCharCode((offset & 1023) + 56320);

    case 3:
      return fromCharCode((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));

    default:
      return fromCharCode((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};

var btou = function btou(b) {
  return b.replace(re_btou, cb_btou);
};

var cb_decode = function cb_decode(cccc) {
  var len = cccc.length,
      padlen = len % 4,
      n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
      chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 255), fromCharCode(n & 255)];
  chars.length -= [0, 0, 2, 1][padlen];
  return chars.join('');
};

var atob = function atob(a) {
  return a.replace(/[\s\S]{1,4}/g, cb_decode);
};

var _decode = function _decode(a) {
  return btou(atob(a));
};

var decode = function decode(a) {
  return _decode(String(a).replace(/[-_]/g, function (m0) {
    return m0 == '-' ? '+' : '/';
  }).replace(/[^A-Za-z0-9\+\/]/g, ''));
};

var base64 = {
  // VERSION: version,
  // atob: atob,
  // btoa: btoa,
  // fromBase64: decode,
  // toBase64: encode,
  // utob: utob,
  encode: encode,
  // encodeURI: encodeURI,
  // btou: btou,
  decode: decode
}; // import md5 from './md5.js';
// function MD5(data) {
//   return data ? md5(data) : '';
// }

function base64Encode(str) {
  return base64.encode(str, false);
}

function base64Decode(str) {
  return base64.decode(str);
}

function getRandomStr(len) {
  var str = '';
  var arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

  for (var i = 0; i < Number(len); i++) {
    var pos = Math.round(Math.random() * (arr.length - 1));
    str += arr[pos];
  }

  return str;
}

function isNumber(inputData) {
  // typeof NaN: number
  // isNaN(inputData)不能判断空串或一个空格
  // 如果是一个空串或是一个空格，而isNaN是做为数字0进行处理的，而parseInt与parseFloat是返回一个错误消息，这个isNaN检查不严密而导致的。
  return !Number.isNaN(parseInt(inputData, 10));
}

function compareVersion(vision1, vision2) {
  var arrVision1 = String(vision1).split('.');
  var arrVision2 = String(vision2).split('.');

  for (var i = 0; i < Math.max(arrVision1.length, arrVision2.length); i++) {
    var n1 = parseInt(arrVision1[i] || 0, 10);
    var n2 = parseInt(arrVision2[i] || 0, 10);
    if (n1 > n2) return 1;
    if (n1 < n2) return -1;
  }

  return 0;
} // /**
//  * js文件MD5值验证
//  * @param md5Value 服务端下发MD5值
//  * @param content 本地加载文件内容
//  * @returns {boolean}
//  */
// function checkMD5(md5Value, fileContent) {
//   try {
//     return md5Value === md5(fileContent);
//   } catch (e) {
//     return false;
//   }
// }


function clone(source) {
  return JSON.parse(JSON.stringify(source));
}

var utils = {
  // MD5: MD5,
  base64Encode: base64Encode,
  base64Decode: base64Decode,
  isNumber: isNumber,
  // checkMD5: checkMD5,
  compareVersion: compareVersion,
  getRandomStr: getRandomStr,
  clone: clone
};

var idManager = function () {
  var _instance = null;

  function IDManager() {
    var _uuid = '';
    var _openid = '';
    var _unionid = '';
    var _userid = '';
    var _alipayid = '';
    var _idType = '';

    function _createUuid() {
      return utils.getRandomStr(10) + Date.now() + utils.getRandomStr(7) + constants.UUID_SUFFIX;
    }

    this.init = function (cb) {
      {
        _idType = userConfig().useOpenid() ? 'openid' : 'uuid';
        ustorage.get(constants.UUID, function (uuid) {
          if (uuid) {
            _uuid = uuid;
          } else {
            _uuid = _createUuid();
            ustorage.set(constants.UUID, _uuid);
          }

          if (userConfig.useOpenid) {
            ustorage.get(constants.OPENID, function (openid) {
              _openid = openid;
              cb && cb();
            });
          } else {
            cb && cb();
          }
        });
      }
    };

    {
      this.getOpenIdAsync = function (options) {
        wx.login({
          success: function success(res) {
            if (res.code) {
              urequest({
                url: constants.GET_OPENID_URL,
                method: 'GET',
                data: {
                  key: userConfig().appKey(),
                  code: res.code
                },
                success: function success(resp) {
                  if (resp && resp.statusCode === 200 && resp.data && resp.data.data) {
                    var data = resp.data.data;
                    return options.success && options.success(data.oid, data.uid);
                  }

                  options.fail && options.fail();
                },
                fail: function fail() {
                  options.fail && options.fail();
                }
              });
            } else {
              options.fail && options.fail();
            }
          },
          fail: function fail() {
            options.fail && options.fail();
          }
        });
      };
    }

    this.getIdType = function () {
      return _idType;
    };

    this.getIdTracking = function () {
      var idTracking = {};

      if (_uuid) {
        idTracking.uuid = _uuid;
      }

      if (_openid) {
        idTracking.openid = _openid;
      }

      if (_unionid) {
        idTracking.unionid = _unionid;
      }

      if (_alipayid) {
        idTracking.alipay_id = _alipayid;
      }

      if (_userid) {
        idTracking.userid = _userid;
      }

      return idTracking;
    };

    this.setOpenid = function (openid) {
      if (!_openid && openid) {
        _openid = openid;
        ustorage.set(constants.OPENID, openid);
      }
    };

    this.setUnionid = function (unionid) {
      if (!_unionid && unionid) {
        _unionid = unionid;
        ustorage.set(constants.UNIONID, unionid);
      }
    };

    this.setUserid = function (userid) {
      if (!_userid && userid) {
        _userid = userid;
        ustorage.set(constants.USERID, userid);
      }
    };

    this.getId = function () {
      {
        if (userConfig().useOpenid()) {
          return _openid;
        } else {
          return _uuid;
        }
      }
    };
  }

  return function () {
    if (!_instance) {
      _instance = new IDManager();
    }

    return _instance;
  };
}();

var MAX_SOURCE_LENGTH = 3;

var shareList = function () {
  var _instance = null;
  var _shares = [];
  var _ssrc = '';

  function ShareList() {
    return {
      add: function add(result) {
        ulog().v('share origin: %o', result);
        var share = {
          title: result.title,
          path: result.path.split('?')[0],
          _um_sts: Date.now()
        };
        var sharePath = result.path;
        var id = idManager().getId();

        if (id) {
          var ids = _ssrc.split(','); // 过滤空id


          ids = ids.filter(function (item) {
            return item.length > 0;
          }); // 去掉自己以及自己后面的id

          var index = ids.indexOf(id);

          if (index >= 0) {
            ids = ids.slice(0, index);
          }

          if (ids.length < MAX_SOURCE_LENGTH) {
            // 分享仅到第三层
            ids.push(id);
          }

          var newShareSource = ids.join(',');

          if (sharePath.indexOf('?') !== -1) {
            sharePath += '&_um_ssrc=' + newShareSource;
          } else {
            sharePath += '?_um_ssrc=' + newShareSource;
          }

          var sts = Date.now();
          sharePath += '&_um_sts=' + sts;
          result.path = sharePath;
          share._um_ssrc = newShareSource;
          share._um_sts = sts;
        }

        _shares.push(share);

        ulog().v('share: %o', result);
        return result;
      },
      setShareSource: function setShareSource(source) {
        _ssrc = source;
      },
      clear: function clear() {
        // cache().remove(constants.SHARES);
        _shares.length = 0;
      },
      get: function get() {
        return _shares;
      }
    };
  }

  return function () {
    if (!_instance) {
      _instance = new ShareList();
    }

    return _instance;
  };
}();

var EKVS = 'ekvs';
var EVENT_MAX_COUNT = 10000; // 本地最多存储这么多ekv数据

var MEMORY_MAX_COUNT = 1; // 内存中存储的最大数据数量，超过则缓存到本地

function Event(id, properties) {
  this.id = id;
  this.ts = Date.now();

  var propsType = _typeof(properties);

  if (propsType === 'string' && properties) {
    this[id] = properties;
  } else if (propsType === 'object') {
    for (var key in properties) {
      if ({}.hasOwnProperty.call(properties, key)) {
        this[key] = properties[key];
      }
    }
  }
}

var eventManager = function () {
  var _instance;

  var _sessionId;

  var _memoryEvents = []; // 在创建sessionId前添加的事件

  var _noSessionEvents = [];

  function _cacheEvents() {
    if (_memoryEvents.length) {
      var ekvs = cache().get(EKVS); // 本地最多存储 EVENT_MAX_COUNT 条数据，「多余数据」暂时先抛弃

      if (_getCacheEventsLength(ekvs) + _memoryEvents.length <= EVENT_MAX_COUNT) {
        ekvs = _buildEkvs(ekvs, _memoryEvents);
        cache().set(EKVS, ekvs);
      }
    }
  }

  function _buildEkvs(ekvs, memoryEvents) {
    ekvs = ekvs || {};
    var events = ekvs[_sessionId];

    if (Array.isArray(events) && events.length) {
      ekvs[_sessionId] = events.concat(memoryEvents);
    } else {
      ekvs[_sessionId] = [].concat(memoryEvents);
    }

    return ekvs;
  }

  function _getCacheEventsLength(eventsMap) {
    var len = 0;

    for (var key in eventsMap) {
      if (Array.isArray(eventsMap[key])) {
        len += eventsMap[key].length;
      }
    }

    return len;
  }

  function init() {
    return {
      addEvent: function addEvent(id, properties) {
        var event = new Event(id, properties);

        if (_sessionId) {
          _memoryEvents.unshift(event);

          if (_memoryEvents.length > MEMORY_MAX_COUNT) {
            _cacheEvents(_sessionId);

            _memoryEvents.length = 0;
          }
        } else {
          ulog().w('session id is null: ', _sessionId);

          _noSessionEvents.unshift(event);
        }
      },
      setSessionId: function setSessionId(sessionId) {
        _sessionId = sessionId;
        ulog().v('setSessionId: ', _sessionId);

        if (Array.isArray(_noSessionEvents) && _noSessionEvents.length && _sessionId) {
          for (var i = 0; i < _noSessionEvents.length; i++) {
            this.addEvent(_noSessionEvents[i]);
          }

          _noSessionEvents.length = 0;
        }
      },
      getEkvs: function getEkvs() {
        var ekvs = cache().get(EKVS);

        if (_memoryEvents && _memoryEvents.length) {
          ekvs = _buildEkvs(ekvs, _memoryEvents);
        }

        return ekvs;
      },
      clear: function clear() {
        cache().remove(EKVS);
        _memoryEvents.length = 0;
      }
    };
  }

  return function () {
    if (!_instance) {
      _instance = init();
    }

    return _instance;
  };
}();

var MOBILE_NETWORK_2G = '2g';
var MOBILE_NETWORK_3G = '3g';
var MOBILE_NETWORK_4G = '4g';
var MOBILE_NETWORK_NONE = 'none';
var BLANK_SPACE = ' ';
var REALTIME_FIELDS = ['access', // 联网类型
'access_subtype' // 联网子类型
];

var Header = function () {
  var _instance = null;

  function init() {
    var _loaded = false;
    var _header = {};
    {
      _header.sdk_type = 'wxmp';
      _header.platform = 'wx';
    }

    function _generate(callback) {
      udevice.getSystemInfo(function (deviceInfo) {
        udevice.getNetworkInfo(function (netInfo) {
          var access = netInfo.type || netInfo.networkType;

          if (access === MOBILE_NETWORK_NONE) {
            access = 'unknown';
          }

          var data = cache().get(constants.IMPRINT);

          if (data) {
            _header.imprint = data; // 发送策略
          }

          _build(deviceInfo, access);

          _output(deviceInfo);

          callback && callback();
        });
      });
    }

    function _build(deviceInfo, access, userInfo) {
      _header.userInfo = userInfo;
      _header.device_type = 'Phone';
      _header.sdk_version = constants.IMPL_VERSION;
      _header.appkey = userConfig().appKey(); // if (!uniqueId && ("wx" === BuildTarget.ALIPAY
      //   || "wx" === BuildTarget.WEIXIN)) {
      //   uniqueId = _fakeid;
      // }

      if (deviceInfo) {
        var model = deviceInfo.model || '';
        var product = deviceInfo.product || '';
        var platform = deviceInfo.platform || '';
        var brand = deviceInfo.brand || '';
        var brandL = brand.toLowerCase();
        var w;
        var h;
        var resolution; // 分辨率,大的在前面,如：1920*1080

        {
          _header.platform_sdk_version = deviceInfo.SDKVersion;
        }
        {
          _header.platform_version = deviceInfo.version;
          {
            w = Math.round(deviceInfo.screenWidth * deviceInfo.pixelRatio);
            h = Math.round(deviceInfo.screenHeight * deviceInfo.pixelRatio);
          }
          resolution = w > h ? w + '*' + h : h + '*' + w; // 分辨率,大的在前面,如：1920*1080

          _header.os = platform;
          _header.font_size_setting = deviceInfo.fontSizeSetting;
          _header.device_model = model.toLowerCase().indexOf(brandL) > -1 ? model : brandL + BLANK_SPACE + model; // 设备型号

          _header.device_brand = brand; // 设备生产商
          // _header.channel = brandL; // 这里渠道暂时先用 生产商的名字

          _header.device_manufacturer = brandL;
          _header.device_manuid = model.toLowerCase().indexOf(brandL) > -1 ? model : brandL + BLANK_SPACE + model; // 设备品牌/型号

          _header.device_name = model.toLowerCase().indexOf(brandL) > -1 ? model : brandL + BLANK_SPACE + model; // 内部产品代号

          _header.os_version = deviceInfo.system; // os版本号

          _header.resolution = resolution;
          _header.language = deviceInfo.language; // 语言，zh
        }
      }

      switch (access) {
        case MOBILE_NETWORK_4G:
          _header.access_subtype = 'LTE';
          _header.access = '4G';
          break;

        case MOBILE_NETWORK_3G:
          _header.access_subtype = 'CDMA';
          _header.access = '3G';
          break;

        case MOBILE_NETWORK_2G:
          _header.access_subtype = 'GRPS';
          _header.access = '2G';
          break;

        default:
          _header.access = access;
          delete _header.access_subtype;
          break;
      }
    } // 该方法主要用于调试，定位问题


    function _output(deviceInfo) {
      var items = [];

      if (deviceInfo) {
        items.push({
          name: '系统名',
          value: deviceInfo.platform
        });
        items.push({
          name: '支付宝版本号',
          value: deviceInfo.version
        });
      }

      items.push({
        name: '设备型号',
        value: _header.device_model
      });
      items.push({
        name: '设备生产商',
        value: _header.device_brand
      });
      items.push({
        name: 'os版本号',
        value: _header.os_version
      });
      items.push({
        name: '网络类型',
        value: _header.access
      });
      items.push({
        name: '运营商',
        value: _header.access_subtype
      });
      items.push({
        name: '分辨率',
        value: _header.resolution
      });
      items.push({
        name: 'screenWidth',
        value: deviceInfo.screenWidth
      });
      items.push({
        name: 'screenHeight',
        value: deviceInfo.screenHeight
      });
      items.push({
        name: 'pixelRatio',
        value: deviceInfo.pixelRatio
      });
      var info = '';

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        info += item.name + ': ' + item.value + '; ';
      }

      ulog().v('调试辅助信息: ', info);
    }

    return {
      // 初始化header
      init: function init() {
        _generate(function () {
          _loaded = true;
        });
      },
      isLoaded: function isLoaded() {
        return _loaded;
      },
      // 获取header对象
      get: function get() {
        return _header;
      },
      getSDKType: function getSDKType() {
        return _header.sdk_type;
      },
      getPlatform: function getPlatform() {
        return _header.platform;
      },
      getRealtimeFields: function getRealtimeFields() {
        var realtimeFields = {};
        REALTIME_FIELDS.forEach(function (item) {
          realtimeFields[item] = _header[item];
        });
        return realtimeFields;
      },
      setIdTracking: function setIdTracking(idTracking) {
        this.setItem('id_tracking', idTracking);
      },
      setIdType: function setIdType(idType) {
        this.setItem('id_type', idType);
      },
      setItem: function setItem(key, value) {
        _header[key] = value;
      },
      getItem: function getItem(key) {
        return _header[key];
      },
      updateExtraInfo: function updateExtraInfo() {
        udevice.getDeviceInfo(function (deviceInfo) {
          _header.device_info = deviceInfo || '';
        });
      }
    };
  }

  return {
    instance: function instance() {
      if (!_instance) {
        _instance = init();
      }

      return _instance;
    }
  };
}();

var DataType = {
  HALF_SESSION: 'half_session',
  CLOSE_SESSION: 'close_session',
  EKV: 'ekv'
};

var sessionManager = function () {
  var _instance = null;
  var _resumeTime = null;
  var _currentSession = null; // 当前session对象

  function init() {
    return {
      resume: function resume(options) {
        var newSession = false;

        if (!_currentSession) {
          _currentSession = cache().get(constants.CURRENT_SESSION);
        }

        var date = new Date();
        _resumeTime = date.getTime();

        if (!_currentSession || !_currentSession.end_time || _resumeTime - _currentSession.end_time > constants.SESSION_INTERVAL) {
          newSession = true;

          _createNewSession(options);

          ulog().v('开始新的session(%s): ', _currentSession.id, _currentSession);
        } else {
          ulog().v('延续上一次session(%s): %s ', _currentSession.id, date.toLocaleTimeString(), _currentSession);
        }

        return newSession;
      },
      // 在onHide方法时闭合session
      pause: function pause() {
        _endSession();
      },
      // 获取当前的sessionId，没有则返回空
      getCurrentSessionId: function getCurrentSessionId() {
        return (_currentSession || {}).id;
      },
      getCurrentSession: function getCurrentSession() {
        return _currentSession;
      },
      cloneCurrentSession: function cloneCurrentSession() {
        return utils.clone(_currentSession);
      }
    };
  }

  function _getUmParams(query) {
    var um_query = {};

    for (var i in query) {
      if (i.indexOf('_um_') === 0) {
        um_query[i] = query[i];
      }
    } // ulog().v('query: ', query);
    // ulog().v('_um_params: ', um_query);


    return um_query;
  } // 开始一个新session


  function _createNewSession(newOptions) {
    try {
      var prevOptions = (_currentSession || {}).options || {};
      var launchOptions = Object.assign({}, _getUmParams(newOptions.query));
      launchOptions.path = newOptions.path || prevOptions.path;
      launchOptions.scene = newOptions.scene ? Header.instance().getPlatform() + '_' + newOptions.scene : prevOptions.scene;
      ulog().v('session options: ', launchOptions);
      var um_ssrc = launchOptions[constants.UM_SSRC];

      if (um_ssrc) {
        shareList().setShareSource(um_ssrc);
      }

      var ts = Date.now();
      _currentSession = {
        id: utils.getRandomStr(10) + ts,
        start_time: ts,
        // duration: 0,
        // url: options.path,
        options: launchOptions
      };
    } catch (e) {
      ulog().e('生成新session失败: ', e);
    }
  } // 结束当前session，由于30秒机制，一个session会被结束多次


  function _endSession() {
    if (_currentSession) {
      var date = new Date();
      _currentSession.end_time = date.getTime();

      if (typeof _currentSession.duration !== 'number') {
        _currentSession.duration = 0;
      }

      _currentSession.duration = _currentSession.end_time - _resumeTime;
      cache().set(constants.CURRENT_SESSION, _currentSession); // ulog().v('退出会话(%s): %s %o', _currentSession.id, date.toLocaleTimeString(), _currentSession);

      ulog().v('退出会话(%s): %s ', _currentSession.id, date.toLocaleTimeString(), _currentSession);
    }
  }

  return function () {
    if (!_instance) {
      _instance = init();
    }

    return _instance;
  };
}();

function build(dataType) {
  var data = null;

  switch (dataType) {
    case DataType.HALF_SESSION:
      data = _buildHalfSession();
      break;

    case DataType.CLOSE_SESSION:
      data = _buildCloseSession();
      break;

    case DataType.EKV:
      data = _buildEkv();
      break;

    default:
      break;
  }

  return data;
}

function _buildHalfSession() {
  var data = null;
  var session = sessionManager().cloneCurrentSession();

  if (session) {
    data = {
      header: {
        st: '1'
      },
      analytics: {
        sessions: [session]
      }
    };
  }

  return data;
}

function _buildCloseSession() {
  var data = null;
  var analytics = {};
  var session = sessionManager().cloneCurrentSession();

  if (session) {
    var pages = pageList().get();
    var shares = shareList().get();

    if (Array.isArray(pages) && pages.length) {
      session.pages = utils.clone(pages);
    }

    if (Array.isArray(shares) && shares.length) {
      session.shares = utils.clone(shares);
    }

    pageList().clear();
    shareList().clear();
    analytics.sessions = [session];
  }

  var ekvs = eventManager().getEkvs();

  if (ekvs) {
    analytics.ekvs = utils.clone(ekvs);
    eventManager().clear();
  }

  if (analytics.sessions || analytics.ekvs) {
    data = {
      analytics: analytics
    };
  }

  return data;
}

function _buildEkv() {
  var data = null;
  var ekvs = eventManager().getEkvs();

  if (ekvs) {
    data = {
      analytics: {
        ekvs: utils.clone(ekvs)
      }
    };
    eventManager().clear();
  }

  return data;
} // var rootMap = {
//   'header': 'h',
//   'analytics': 'a',
// };


var analyticsMap = {
  sessions: 'sn',
  // pages: 'p',
  // shares: 'sr',
  ekvs: 'e'
};
var headerMap = {
  sdk_type: 'sdt',
  access: 'ac',
  access_subtype: 'acs',
  device_model: 'dm',
  language: 'lang',
  device_type: 'dt',
  device_manufacturer: 'dmf',
  device_name: 'dn',
  platform_version: 'pv',
  id_type: 'it',
  font_size_setting: 'fss',
  os_version: 'ov',
  device_manuid: 'did',
  platform_sdk_version: 'psv',
  device_brand: 'db',
  appkey: 'ak',
  _id: 'id',
  id_tracking: 'itr',
  imprint: 'imp',
  sdk_version: 'sv',
  resolution: 'rl'
};
var idMap = {
  uuid: 'ud',
  unionid: 'und',
  openid: 'od',
  alipay_id: 'ad',
  device_id: 'dd',
  userid: 'cuid'
};

function mangle(data) {
  return {
    h: _mangleHeader(data.header, headerMap),
    a: _mangleAnalytics(data.analytics, analyticsMap)
  };
}

function _mangleHeader(header, map) {
  var result = _mangleObj(header, map);

  if (header.id_tracking) {
    result[map.id_tracking || 'id_tracking'] = _mangleObj(header.id_tracking, idMap);
  }

  return result;
}

function _mangleObj(obj, map) {
  var result = {};

  for (var key in obj) {
    if (map[key]) {
      result[map[key]] = obj[key];
    } else {
      result[key] = obj[key];
    }
  }

  return result;
}

function _mangleAnalytics(analytics, map) {
  var result = {};

  if (analytics) {
    var ekvs = analytics.ekvs;
    var sessions = analytics.sessions;

    if (ekvs) {
      result[map.ekvs] = ekvs;
    }

    if (Array.isArray(sessions)) {
      result[map.sessions] = sessions;
    } // if (Array.isArray(sessions)) {
    //   result[map.sessions] = sessions.map(function (session) {
    //     var mangleSession = {};
    //     for (const key in session) {
    //       if (map[key]) {
    //         mangleSession[map[key]] = session[key];
    //       } else {
    //         mangleSession[key] = session[key];
    //       }
    //     }
    //     return mangleSession;
    //   });
    // }

  }

  return result;
}

function request(data, successCallback, failCallback, completedCallback) {
  Header.instance().setIdType(idManager().getIdType());
  Header.instance().setIdTracking(idManager().getIdTracking());
  var header = utils.clone(Header.instance().get());
  data.header = Object.assign(header, data.header, {
    ts: Date.now()
  });
  var mangleData = mangle(data);
  var requestData = jsonUtil.stringify(mangleData);
  var config = {
    url: constants.LOG_URL,
    method: 'POST',
    data: utils.base64Encode(requestData),
    success: function success(resp) {
      var statusCode = resp.code || resp.status || resp.statusCode;

      if (statusCode === 200 || statusCode === 413) {
        ulog().i('数据发送成功: ', requestData); // 在此处将imprint内容加入到本地缓存中

        saveImprint((resp.data || {}).imprint);
        typeof successCallback === 'function' && successCallback(resp);
      } else {
        ulog().w('数据发送失败: ', requestData);
        typeof failCallback === 'function' && failCallback();
      }
    },
    fail: function fail(isTimeout) {
      ulog().w('数据发送' + isTimeout ? '超时: ' : '失败: ', requestData);
      typeof failCallback === 'function' && failCallback();
    },
    complete: function complete() {
      typeof completedCallback === 'function' && completedCallback();
    }
  };
  urequest(Object.assign(config, buildHttpHeader()));
} // 服务端下发发送策略


function saveImprint(imprint) {
  if (imprint) {
    cache().set(constants.IMPRINT, imprint);
    Header.instance().setItem(constants.IMPRINT, imprint);
    var imprintObj = jsonUtil.parse(utils.base64Decode(imprint));
    ulog().v('imprint: %o', imprintObj); // 在此处获取imprint中的report_policy和report_interval字段并存储

    var reportPolicy = imprintObj.report_policy;

    if (reportPolicy && utils.isNumber(reportPolicy)) {
      cache().set(constants.REPORT_POLICY, reportPolicy);

      if (reportPolicy === constants.REPORT_POLICY_INTERVAL) {
        var intervalTime = imprintObj.report_interval;

        if (intervalTime && utils.isNumber(intervalTime)) {
          if (intervalTime <= constants.EVENT_SEND_MIN_INTERVAL) {
            intervalTime = constants.EVENT_SEND_MIN_INTERVAL;
          } else if (intervalTime > constants.EVENT_SEND_MAX_INTERVAL) {
            intervalTime = constants.EVENT_SEND_MAX_INTERVAL;
          }

          cache().set(constants.REPORT_INTERVAL_TIME, intervalTime);
        }
      }
    }
  }
}

function buildHttpHeader() {
  var headerType;
  {
    headerType = 'wxmp/json';
  }
  var header = {
    'Content-Type': headerType,
    'Msg-Type': headerType
  };
  {
    return {
      header: header
    };
  }
}

var MAX_QUEUE_COUNT = 50; // 为防止因网络异常导致缓存过大，设置缓存个数上限
// var MAX_SEND_COUNT = 1; // 为防止因网络异常导致不停发送，设置发送次数上限

function Queue(maxCount) {
  var _maxCount = maxCount;
  var _items = [];

  this.enqueue = function (item) {
    if (typeof _maxCount === 'number' && this.size() >= _maxCount) {
      this.dequeue();
    }

    _items.push(item);
  };

  this.dequeue = function () {
    return _items.shift();
  };

  this.front = function () {
    return _items[0];
  };

  this.isEmpty = function () {
    return _items.length === 0;
  };

  this.clear = function () {
    _items.length = 0;
  };

  this.size = function () {
    return _items.length;
  };

  this.items = function () {
    return _items;
  };

  this.print = function () {
    console.log(_items.toString());
  };
}

var requestQueue = function () {
  var _instance = null;
  var _running = false;
  var _failRequests = [];

  var _queue = new Queue(MAX_QUEUE_COUNT);

  function _enqueueRequest(dataType, cb) {
    if (Header.instance().isLoaded()) {
      var data = build(dataType);
      var realtimeFields = Header.instance().getRealtimeFields();
      data.header = Object.assign({}, data.header, realtimeFields);

      _queue.enqueue(data);

      typeof cb === 'function' && cb();
    } else {
      setTimeout(function () {
        _enqueueRequest(dataType, cb);
      }, 100);
    }
  }

  function _sendQueue(completedCallback) {
    var data = _queue.front();

    var success = function success() {
      _queue.dequeue();

      _sendQueue(completedCallback);
    };

    var fail = function fail() {
      // 发送失败则将该条数据添加到队列尾部，防止影响后续数据的发送
      var item = _queue.dequeue();

      item && _failRequests.push(item);

      _sendQueue(completedCallback);
    };

    if (data) {
      request(data, success, fail);
    } else {
      _processFailRequests();

      completedCallback();
    }
  }

  function _processFailRequests() {
    // 发送完成后将失败的请求重新添加到队列中
    _failRequests.forEach(function (item) {
      _queue.enqueue(item);
    });

    _failRequests.length = 0;
  }

  function _startSend(completedCallback) {
    if (!idManager().getId()) {
      ulog().i('获取id标识失败，暂缓发送');
      typeof completedCallback === 'function' && completedCallback();
      return;
    }

    if (_running) {
      ulog().i('队列正在发送中');
      return;
    } // 检查是否有网络，只有明确没有网络时才不发送


    udevice.checkNetworkAvailable(function (available) {
      if (available !== false) {
        _running = true;

        _sendQueue(function () {
          _running = false;
          typeof completedCallback === 'function' && completedCallback();
        });
      } else {
        typeof completedCallback === 'function' && completedCallback();
      }
    });
  }

  function RequestQueue() {
    this.send = function (dataType, completedCallback) {
      if (dataType) {
        this.add(dataType, function () {
          _startSend(completedCallback);
        });
      } else {
        _startSend(completedCallback);
      }
    };

    this.add = function (dataType, cb) {
      _enqueueRequest(dataType, cb);
    };

    this.load = function () {
      var items = cache().get(constants.REQUESTS);

      if (items && items.length) {
        items.forEach(function (item) {
          _queue.enqueue(item);
        });
      }

      cache().remove(constants.REQUESTS);
    };

    this.save = function () {
      cache().set(constants.REQUESTS, utils.clone(_queue.items()));

      _queue.clear(); // 一定要先保存再清空，否则保存的永远是空数据

    };
  }

  return function () {
    if (!_instance) {
      _instance = new RequestQueue();
    }

    return _instance;
  };
}();

function UmengAnalysisLib() {
  var _inited = false; // 为了防止小程序框架级别的show和hide方法没有成对调用导致session计算负数问题

  var _resumed = false; // this._preLastSendTime = 0;
  // var _sending = false;

  function _init() {
    idManager().init(function () {
      Header.instance().init();
      ulog().v('Header初始化成功: ', Header.instance().get());
    });
  }

  function _shouldSendEvents(now) {
    var shouldSend = false;
    var sendPolicy = cache().get(constants.REPORT_POLICY); // 间隔发送

    if (sendPolicy && sendPolicy === constants.REPORT_POLICY_INTERVAL) {
      var intervalTime = cache().get(constants.REPORT_INTERVAL_TIME);
      var lastSendTime = cache().get(constants.EVENT_LAST_SEND_TIME);
      shouldSend = !lastSendTime; // 没有lastSendTime，即为首次发送，应发送

      intervalTime = intervalTime || constants.EVENT_SEND_MIN_INTERVAL;
      var interval = now - lastSendTime;
      shouldSend = shouldSend || interval > intervalTime * 1000;
    }

    return shouldSend;
  }

  function _updateLastSendTime(now) {
    // this._preLastSendTime = cache().get(constants.EVENT_LAST_SEND_TIME);
    cache().set(constants.EVENT_LAST_SEND_TIME, now);
  } // function _recoverLastSendTime () {
  //   cache().set(constants.EVENT_LAST_SEND_TIME, this._preLastSendTime);
  // }
  // 1.ekv中存在规则不合法情况，丢弃整条事件
  // 2.eventid长度不能超过128个字符
  // 3.key长度不能超过256个字符
  // 4.每个event携带key个数不能超过100个


  function _checkEvent(eventId, properties) {
    if (!(eventId && typeof eventId === 'string')) {
      ulog().e('please check trackEvent id. id should be "string" and not null');
      return false;
    }

    if (eventId.length > constants.MAX_EVENTID_LENGTH) {
      ulog().e('The maximum length of event id shall not exceed ' + constants.MAX_EVENTID_LENGTH);
      return false;
    } // properties的合法类型为 string | object(not include Array)


    if (properties && (_typeof(properties) !== 'object' || Array.isArray(properties)) && typeof properties !== 'string') {
      ulog().e('please check trackEvent properties. properties should be string or object(not include Array)');
      return false;
    }

    if (_typeof(properties) === 'object') {
      var count = 0;

      for (var key in properties) {
        if ({}.hasOwnProperty.call(properties, key)) {
          if (key.length > constants.MAX_PROPERTY_KEY_LENGTH) {
            ulog().e('The maximum length of property key shall not exceed ' + constants.MAX_PROPERTY_KEY_LENGTH);
            return false;
          }

          if (count >= constants.MAX_PROPERTY_KEYS_COUNT) {
            ulog().e('The maximum count of properties shall not exceed ' + constants.MAX_PROPERTY_KEYS_COUNT);
            return false;
          }

          count += 1;
        }
      }
    }

    return true;
  }

  this.init = function (cb) {
    ulog().v('sdk version: ' + constants.IMPL_VERSION); // 防止重复初始化

    if (_inited) {
      ulog().v('Lib重复实例化');
      return;
    }

    cache().load(function () {
      ulog().v('cache初始化成功: ', cache().getAll());

      _init();

      _inited = true;
      typeof cb === 'function' && cb();
      ulog().tip('SDK集成成功');
    });
  };

  this.resume = function (showOptions) {
    if (!_inited || _resumed) {
      return;
    }

    ulog().v('showOptions: ', showOptions);
    _resumed = true;
    requestQueue().load();
    var newSession = sessionManager().resume(showOptions);
    var sessionId = sessionManager().getCurrentSessionId();
    eventManager().setSessionId(sessionId);

    if (newSession) {
      var self = this;
      requestQueue().add(DataType.HALF_SESSION, function () {
        if (userConfig().useOpenid() && userConfig().autoGetOpenid() && !idManager().getId()) {
          idManager().getOpenIdAsync({
            success: function success(id) {
              ulog().v('获取openid成功: %s', id);
              self.setOpenid(id);
            },
            fail: function fail() {
              ulog().v('获取openid失败');
            }
          });
        } else {
          requestQueue().send();
        }
      });
    }
  };

  this.pause = function () {
    if (!_inited) {
      return;
    }

    _resumed = false;
    sessionManager().pause();
    requestQueue().send(DataType.CLOSE_SESSION, function () {
      requestQueue().save();
      cache().save();
      ulog().v('cache save success');
    });
  };

  this.setOpenid = function (id) {
    if (!idManager().getId()) {
      ulog().v('setOpenId: %s', id);
      idManager().setOpenid(id);
      requestQueue().send();
    }
  };

  this.setUnionid = function (id) {
    ulog().v('setUnionid: %s', id);
    idManager().setUnionid(id);
  };

  this.setUserid = function (id) {
    ulog().v('setUserid: %s', id);
    idManager().setUserid(id);
  };

  this.trackEvent = function (id, properties) {
    if (!_inited) {
      return;
    }

    ulog().v('event: ', id, properties);

    if (_checkEvent(id, properties)) {
      eventManager().addEvent(id, properties);
      var now = Date.now();

      if (_shouldSendEvents(now)) {
        _updateLastSendTime(now);

        requestQueue().send(DataType.EKV, function () {});
      }
    }
  };

  this.trackShare = function (shareResult) {
    if (_inited) {
      try {
        shareResult = shareList().add(shareResult);
        ulog().v('sharePath: ', shareResult.path);
      } catch (error) {
        ulog().v('shareAppMessage: ', error);
      }

      return shareResult;
    }
  };

  this.trackPageStart = function (page) {
    if (_inited) {
      pageList().addPageStart(page);
    }
  };

  this.trackPageEnd = function (page) {
    if (_inited) {
      pageList().addPageEnd(page);
    }
  };
} // import urequest from './common/urequest.js';
// import utils from './utils/index.js';
// import md5 from './utils/md5.js';
// import base64 from './utils/base64.js';
// var STATUS = {
//   SUCCESS: 0,
//   FAIL: -1
// };
// var modules = {
//   md5: md5,
//   base64: base64
// };


var callQueue = []; // 接口调用缓存队列

function SdkUpdater() {}

SdkUpdater.prototype = {
  // loadSDK: function (cb) {
  //   var me = this;
  //   try {
  //     ustorage.get(constants.SDK_INFO, function (sdkInfo) {
  //       if (sdkInfo && sdkInfo.md5) {
  //         me.readSDKCode(sdkInfo, function (status, sdkCode) {
  //           cb(status, sdkCode, sdkInfo);
  //         });
  //       } else {
  //         cb(STATUS.FAIL);
  //       }
  //     });
  //   } catch (e) {
  //     cb(STATUS.FAIL);
  //   }
  // },
  // /**
  //  * 获取并验证sdk存储信息
  //  * @param sdkStorageInfo
  //  * @param cb
  //  */
  // readSDKCode: function (sdkInfo, cb) {
  //   try {
  //     ulog().v('current sdk:' + sdkInfo.version + sdkInfo.md5 + sdkInfo.filePath);
  //     ustorage.get(constants.SDK_CODE, function (sdkCode) {
  //       var cacheCode = utils.decode(sdkCode);
  //       if (utils.checkMD5(sdkInfo.md5, cacheCode)) {
  //         cb(STATUS.SUCCESS, cacheCode);
  //       } else {
  //         cb(STATUS.FAIL);
  //       }
  //     }, function () {
  //       cb(STATUS.FAIL);
  //     });
  //   } catch (e) {
  //     cb(STATUS.FAIL);
  //   }
  // },
  // /**
  //  * 根据服务端提供URL下载文件链接并存储
  //  */
  // downloadSDK: function (sdkInfo) {
  //   // ulog().v('下载sdk： ' + JSON.stringify(sdkInfo));
  //   try {
  //     urequest({
  //       url: sdkInfo.fileUrl,
  //       dataType: 'text',
  //       success: function (res) {
  //         // sdk代码下载成功，将代码保存到storage
  //         // ulog().v('sdk下载成功： ' + JSON.stringify(data));
  //         try {
  //           var data = res.data;
  //           if (typeof data === 'string' && data.length > 0 && utils.checkMD5(sdkInfo.md5, data)) {
  //             ustorage.set(constants.SDK_CODE, utils.encode(data), function () {
  //               // sdk代码存储成功后才保存sdk配置信息，这样在下次加载大体积的sdk代码前可以先检查sdk配置信息是否存在
  //               ustorage.set(constants.SDK_INFO, sdkInfo);
  //             }, function () {
  //               ustorage.remove(constants.SDK_CODE);
  //               ustorage.remove(constants.SDK_INFO);
  //             });
  //           }
  //         } catch (e) {
  //           ulog().w('sdk保存时遇到异常: ' + e);
  //         }
  //       },
  //       fail: function (/* data, code */) {
  //         // ulog().w('sdk下载失败');
  //       }
  //     });
  //   } catch (e) {
  //     // empty
  //   }
  // },
  // /**
  //  * 检测是否sdk版本有更新
  //  * @param sdkVersion
  //  * @param appKey
  //  * @param appVersion
  //  * @param cb
  //  */
  // checkVersionNew: function (data) {
  //   var me = this;
  //   udevice.getSystemInfo(function (sysInfo) {
  //     data.systemInfo = sysInfo;
  //     urequest({
  //       url: constants.SDK_UPDATE_SERVER_ADDRESS,
  //       method: 'POST',
  //       data: data,
  //       success: function (resp) {
  //         if (resp.status === 200) {
  //           try {
  //             var res = resp.data;
  //             if (res.code === 200 && res.data && res.data.update) {
  //               var updateInfo = res.data.info;
  //               if (updateInfo && updateInfo.fileUrl && updateInfo.md5) {
  //                 me.downloadSDK(updateInfo);
  //               }
  //             }
  //           } catch (e) {
  //             ulog().w('check new version error: request failed');
  //           }
  //         }
  //       },
  //       fail: function (err, code) {
  //         ulog().w('check new version fail', err, code);
  //       },
  //       complete: function () {
  //         ulog().v('check new version complete');
  //       }
  //     });
  //   });
  // },

  /**
   * 组装方法及参数
   * @param obj
   * @param name
   * @param impl
   */
  createMethod: function createMethod(obj, name, impl) {
    try {
      obj[name] = impl ? function () {
        return impl[name].apply(impl, arguments);
      } : function () {
        callQueue.push([name, [].slice.call(arguments)]);
      };
    } catch (e) {
      ulog().v('create method errror: ', e);
    }
  },

  /**
   * 组装接口
   * @param obj
   * @param impl
   */
  installApi: function installApi(obj, impl) {
    try {
      var list = ['resume', 'pause', 'trackEvent', 'trackPageStart', 'trackPageEnd', 'trackShare', 'setOpenid', 'setUnionid', 'setUserid'];
      var i;
      var len;

      for (i = 0, len = list.length; i < len; i++) {
        this.createMethod(obj, list[i], impl);
      }

      if (impl) {
        for (i = 0, len = callQueue.length; i < len; i++) {
          var v = callQueue[i];

          try {
            impl[v[0]].apply(impl, v[1]);
          } catch (e) {
            ulog().v('impl[v[0]].apply error: ', v[0], e);
          }
        }
      }
    } catch (e) {
      ulog().v('install api errror: ', e);
    }
  } // /**
  //  * 预编译
  //  * @param code
  //  * @param content
  //  * @returns {{}|exports}
  //  */
  // compileModule: function (sdkCode) {
  //   var module = { exports: {} };
  //   var require = function (id) {
  //     var paths = id.split('/');
  //     var name = paths[paths.length - 1];
  //     return modules[name] || {};
  //   };
  //   /* eslint-disable no-eval */
  //   // require作为第二个参数传入只为了防止rollup打包时将require函数删掉
  //   eval(sdkCode, require);
  //   /* eslint-enable no-eval */
  //   return module.exports;
  // },
  // /**
  //  * 模块加载
  //  * @param code
  //  * @param content
  //  * @returns {*}
  //  */
  // loadModule: function (status, sdkCode) {
  //   var Impl;
  //   if (status === STATUS.FAIL) {
  //     Impl = UmengAnalysisLib;
  //     ulog().i('load sdk failed: use origin uma_impl');
  //   } else {
  //     try {
  //       Impl = this.compileModule(sdkCode);
  //     } catch (ex) {
  //       Impl = UmengAnalysisLib;
  //       ulog().w('compileModule failed: use origin uma_impl');
  //     }
  //   }
  //   return Impl;
  // }

};

function rewriteFn(obj, name, newFn) {
  var oldFn = obj[name];

  obj[name] = function (e) {
    newFn.call(this, e);
    oldFn && oldFn.call(this, e);
  };
}

function onAppLaunch(config) {
  try {
    umengAnalysis.init(config);
  } catch (error) {
    ulog().v('onAppLaunch: ', error);
  }
}

function onAppShow(e) {
  try {
    {
      umengAnalysis.resume(e);
    }
  } catch (error) {
    ulog().v('onAppShow: ', error);
  }
}

function onAppHide() {
  try {
    umengAnalysis.pause();
  } catch (error) {
    ulog().v('onAppHide: ', error);
  }
}

function onPageShow() {
  try {
    umengAnalysis.trackPageStart(this.route);
  } catch (error) {
    ulog().v('onPageShow: ', error);
  }
}

function onPageHide() {
  try {
    umengAnalysis.trackPageEnd(this.route);
  } catch (error) {
    ulog().v('onPageHide: ', error);
  }
}

try {
  var oldApp = App;

  App = function App(appOptions) {
    rewriteFn(appOptions, 'onLaunch', function () {
      onAppLaunch(appOptions.umengConfig);
    });
    rewriteFn(appOptions, 'onShow', onAppShow);
    rewriteFn(appOptions, 'onHide', onAppHide);
    oldApp(appOptions);
  };
} catch (e) {
  ulog().w('App重写异常');
}

try {
  var oldPage = Page;

  Page = function Page(pageOptions) {
    rewriteFn(pageOptions, 'onShow', onPageShow);
    rewriteFn(pageOptions, 'onHide', onPageHide);
    rewriteFn(pageOptions, 'onUnload', onPageHide);

    if (pageOptions.onShareAppMessage) {
      var oldOnShareAppMessage = pageOptions.onShareAppMessage;

      pageOptions.onShareAppMessage = function (res) {
        var shareResult = oldOnShareAppMessage.call(this, res);
        return umengAnalysis.trackShare.call(this, shareResult);
      };
    }

    oldPage(pageOptions);
  };
} catch (e) {
  ulog().w('Page重写异常');
}

{
  try {
    var oldComponent = Component;

    Component = function Component(options) {
      try {
        options.methods = options.methods || {};
        var methods = options.methods;
        rewriteFn(methods, 'onShow', onPageShow);
        rewriteFn(methods, 'onHide', onPageHide);
        rewriteFn(methods, 'onUnload', onPageHide);

        if (methods.onShareAppMessage) {
          var oldOnShareAppMessage = methods.onShareAppMessage;

          methods.onShareAppMessage = function (res) {
            var shareResult = oldOnShareAppMessage.call(this, res);
            return umengAnalysis.trackShare.call(this, shareResult);
          };
        }

        oldComponent(options);
      } catch (t) {
        oldComponent(options);
      }
    };
  } catch (e) {
    ulog().w('Component重写异常');
  }
}

var _updater = new SdkUpdater();

var umengAnalysis = {
  _inited: false,
  // _config: null,
  init: function init(config) {
    // this._config = this._config || config;
    if (this._inited) {
      ulog().v('已经实例过，请避免重复初始化');
      return;
    } // var updater = new SdkUpdater();
    // updater.installApi(self, null);
    // ulog().v('安装临时接口成功');


    if (!config) {
      ulog().err('请通过在App内添加umengConfig设置相关信息！');
      return;
    }

    if (!config.appKey) {
      ulog().err('请确保传入正确的appkey');
      return;
    }

    userConfig().set(config);
    ulog().setDebug(config.debug);
    this._inited = true;
    var self = this;

    if (userConfig().useOpenid()) {
      var tip = '您选择了使用openid进行统计，请确保使用setOpenid' + '回传openid或通过设置autoGetOpenid为true，并在友盟后台' + '设置secret由友盟帮您获取';
      ulog().tip_w(tip);
    }

    {
      _init(self);
    }

    function _init(ctx) {
      try {
        var lib = new UmengAnalysisLib();
        ulog().v('成功创建Lib对象');
        lib.init(function () {
          ulog().v('Lib对象初始化成功');

          _updater.installApi(ctx, lib);

          ulog().v('安装Lib接口成功');
        });
      } catch (e) {
        ulog().w('创建Lib对象异常: ' + e);
      }
    }
  } // setConfig: function (config) {
  //   this._config = config;
  // }
  // resume: function () {
  //   _callQueue.push(['resume', [].slice.call(arguments)]);
  // },
  // pause: function () {
  //   _callQueue.push(['pause', [].slice.call(arguments)]);
  // },
  // trackPageStart: function () {
  //   _callQueue.push(['trackPageStart', [].slice.call(arguments)]);
  // },
  // trackPageEnd: function () {
  //   _callQueue.push(['trackPageEnd', [].slice.call(arguments)]);
  // },
  // trackEvent: function () {
  //   _callQueue.push(['trackEvent', [].slice.call(arguments)]);
  // },
  // setOpenid: function () {
  //   _callQueue.push(['setOpenid', [].slice.call(arguments)]);
  // },
  // setUnionid: function () {
  //   _callQueue.push(['setUnionid', [].slice.call(arguments)]);
  // },
  // setUserid: function () {
  //   _callQueue.push(['setUserid', [].slice.call(arguments)]);
  // }

};

try {
  _updater.installApi(umengAnalysis, null);

  ulog().v('安装临时接口成功');
  {
    wx.uma = umengAnalysis;
  }
} catch (error) {
  ulog().w('uma赋值异常: ', error);
}

module.exports = umengAnalysis;